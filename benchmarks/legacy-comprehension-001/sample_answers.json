{
  "answers": [
    {
      "id": 1,
      "answer": "The system has 6 main modules: invoice.py (core invoice and item models), tax_calculator.py (tax calculation logic), payment_processor.py (payment gateway integration), database.py (data persistence), workflow.py (business process orchestration), and validators.py (validation logic)."
    },
    {
      "id": 2,
      "answer": "The invoice has 5 states: DRAFT (initial), PENDING (submitted for approval), APPROVED (approved and ready for payment), PAID (payment completed), and CANCELLED. The flow is typically DRAFT -> PENDING -> APPROVED -> PAID, with CANCELLED available from most states except PAID."
    },
    {
      "id": 3,
      "answer": "The database.py module imports Invoice to deserialize invoice data, the workflow.py module imports Invoice to create new invoices, and payment_processor.py indirectly depends on it through the invoice_db parameter."
    },
    {
      "id": 4,
      "answer": "TaxCalculator has no external dependencies - it's a standalone class. However, it is imported and used by the Invoice class in invoice.py (via the calculate_tax method), and TaxExemptionChecker depends on CustomerDatabase."
    },
    {
      "id": 5,
      "answer": "When Invoice.get_total() is called, it first calculates the subtotal from items, then calls calculate_tax() which imports TaxCalculator, creates an instance, and calls calculate_invoice_tax(). TaxCalculator iterates through each item, gets the tax rate based on tax_code and customer_id, and sums up the tax for all items."
    },
    {
      "id": 6,
      "answer": "PaymentProcessor.process_invoice_payment() retrieves the invoice from invoice_db, validates it's approved, gets the total, calls gateway.charge() with payment method and metadata. On success, it calls invoice.mark_paid() with the transaction_id, which updates the invoice status to PAID and stores payment metadata, then saves the invoice back to invoice_db."
    },
    {
      "id": 7,
      "answer": "This would break PaymentProcessor.process_invoice_payment() which checks if invoice.status == invoice.STATUS_APPROVED, workflow.py's approve_invoice() method which sets this status, and the process_overdue_invoices() method which filters by APPROVED status. Any existing saved invoice data with the old status value would also fail status comparisons."
    },
    {
      "id": 8,
      "answer": "Removing the cache would cause every get_invoice() call to read from disk, significantly impacting performance. The workflow module calls get_invoice() multiple times for operations like submit, approve, and reject. Payment processing would also be slower. However, functionality would still work correctly, just slower."
    },
    {
      "id": 9,
      "answer": "The _should_auto_approve() method automatically approves invoices without manual review in two cases: if the total is less than $100 (low-value transactions), or if the customer has a 'trusted' flag set to True. When submit_invoice() is called, it checks this condition and calls approve_invoice() with 'SYSTEM_AUTO' as the approver."
    },
    {
      "id": 10,
      "answer": "The process_invoice_payment() method attempts payment up to retry_attempts (default 3) times. It loops through attempts, calling gateway.charge(). If successful, it immediately returns. If the error is CARD_DECLINED, it breaks out of the retry loop (no point retrying). For other errors, it continues retrying. After all attempts fail, it returns the last error."
    },
    {
      "id": 11,
      "answer": "invoice.py imports TaxCalculator inside the calculate_tax() method (local import), not at the module level. This avoids a potential circular dependency since tax_calculator.py doesn't import invoice.py directly, though TaxExemptionChecker takes a customer_db parameter. The local import is a workaround for this design issue."
    },
    {
      "id": 12,
      "answer": "_serialize_invoice() converts an Invoice object to a dict using to_dict(), then manually extracts item details into items_detail array. _deserialize_invoice() does the reverse: creates an Invoice object, sets all properties, then recreates InvoiceItem objects from items_detail and adds them to the invoice using add_item()."
    },
    {
      "id": 13,
      "answer": "The code uses several patterns: Strategy pattern (PaymentGateway with test/real modes), Repository pattern (InvoiceDatabase, CustomerDatabase for data access), State machine (Invoice status transitions), Dependency Injection (passing database instances to workflow and processors), and Observer pattern (notification_handlers in workflow)."
    },
    {
      "id": 14,
      "answer": "TaxExemptionChecker checks if a customer is tax exempt by looking for a tax_exempt flag or if their tax_id starts with 'EX-'. It can validate exemption certificates with format EXC-XXXXXX-XX and compare them to stored certificates. However, this doesn't integrate with TaxCalculator - it's a separate validation mechanism."
    },
    {
      "id": 15,
      "answer": "This would affect all invoice calculations: Invoice.get_subtotal() sums item totals, which feeds into tax calculation and final total. The change could cause small rounding discrepancies when totals are recalculated vs cached values (_cached_total). Tests comparing exact decimal amounts might fail. Payment amounts sent to the gateway would be rounded differently."
    },
    {
      "id": 16,
      "answer": "The reject_invoice() method changes the invoice status back to DRAFT, stores rejected_by, rejected_date, and rejection_reason in metadata, saves to database, and triggers an 'invoice_rejected' notification. The invoice can then be modified and resubmitted. Only PENDING invoices can be rejected."
    },
    {
      "id": 17,
      "answer": "TaxCalculator has SPECIAL_REGIONS dict mapping region codes (EU, CA, UK) to their tax rates. When set_region() is called with a valid code, get_tax_rate() checks regional rates before falling back to default TAX_RATES. Additionally, it supports customer-specific tax overrides via add_tax_override()."
    },
    {
      "id": 18,
      "answer": "PaymentProcessor.process_refund() gets the invoice, validates it's PAID status, retrieves payment_id from metadata, calls gateway.refund() with the transaction_id and optional amount. The gateway finds the original transaction, validates the refund amount, generates a refund_id, and returns success. The processor then stores refund_id, refund_amount, and refund_date in invoice metadata and saves it."
    },
    {
      "id": 19,
      "answer": "InvoiceWorkflow.create_invoice() would raise ValueError. The _should_auto_approve() logic wouldn't find the 'trusted' flag, preventing auto-approval. TaxCalculator wouldn't apply customer-specific tax overrides. TaxExemptionChecker methods would return False/None. PaymentProcessor would still work as it doesn't directly check customer existence."
    },
    {
      "id": 20,
      "answer": "InvoiceValidator.validate_invoice() runs five checks: _validate_basic_fields (ID format, required fields), _validate_items (positive quantities/prices, descriptions), _validate_amounts (subtotal >= 0, total >= subtotal), _validate_dates (created <= now, due >= created), and _validate_status_transitions (valid status values). It collects errors and warnings separately, returning True only if no errors exist."
    }
  ]
}
